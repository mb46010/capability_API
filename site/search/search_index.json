{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"HR AI Platform Governance \u00b6 Welcome to the central governance portal for the HR AI Platform. This portal provides a comprehensive view of our capability inventory, security policies, and compliance status. Quick Links \u00b6 Capability Catalog : Browse all available Actions and Flows. Policy Verification Dashboard : View real-time security test results. Architecture Overview : Understand the system design and security model. Onboarding Guide : How to get started as a developer or consumer. Core Initiatives \u00b6 1. Capability Catalog \u00b6 The Capability Catalog transforms our internal registry definitions into browsable entities. It allows you to: - Check data sensitivity levels (Low, Medium, High, Critical). - Identify which actions require Multi-Factor Authentication (MFA) . - See exactly which Policies govern each action. - Visualize complex Orchestration Flows using Mermaid diagrams. 2. Policy Verification \u00b6 Our Policy Verification Dashboard ensures that our access controls are always functioning as expected. It runs 100+ automated scenarios on every change to: - Prevent unauthorized access. - Validate wildcard policy matches. - Ensure time-based and context-based restrictions are enforced. 3. Developer Resources \u00b6 API Usage Guide Security Architecture Troubleshooting","title":"Overview"},{"location":"#hr-ai-platform-governance","text":"Welcome to the central governance portal for the HR AI Platform. This portal provides a comprehensive view of our capability inventory, security policies, and compliance status.","title":"HR AI Platform Governance"},{"location":"#quick-links","text":"Capability Catalog : Browse all available Actions and Flows. Policy Verification Dashboard : View real-time security test results. Architecture Overview : Understand the system design and security model. Onboarding Guide : How to get started as a developer or consumer.","title":"Quick Links"},{"location":"#core-initiatives","text":"","title":"Core Initiatives"},{"location":"#1-capability-catalog","text":"The Capability Catalog transforms our internal registry definitions into browsable entities. It allows you to: - Check data sensitivity levels (Low, Medium, High, Critical). - Identify which actions require Multi-Factor Authentication (MFA) . - See exactly which Policies govern each action. - Visualize complex Orchestration Flows using Mermaid diagrams.","title":"1. Capability Catalog"},{"location":"#2-policy-verification","text":"Our Policy Verification Dashboard ensures that our access controls are always functioning as expected. It runs 100+ automated scenarios on every change to: - Prevent unauthorized access. - Validate wildcard policy matches. - Ensure time-based and context-based restrictions are enforced.","title":"2. Policy Verification"},{"location":"#3-developer-resources","text":"API Usage Guide Security Architecture Troubleshooting","title":"3. Developer Resources"},{"location":"CAPABILITY_REGISTRY/","text":"Developer Guide: Capability Registry \u00b6 Overview \u00b6 The Capability Registry is the central source of truth for all HR Platform capabilities (Actions and Flows). It ensures consistency between policy definitions, implementation logic, and runtime execution. File Structure \u00b6 Registry definitions are stored in a single YAML file: config/capabilities/index.yaml Example Entry \u00b6 1 2 3 4 5 6 7 - id : \"workday.hcm.get_employee\" name : \"Get Employee Profile\" domain : \"workday.hcm\" type : \"action\" sensitivity : \"medium\" tags : [ \"read-only\" , \"hcm\" , \"pii\" ] description : \"Retrieve basic public profile information for an employee\" Adding a New Capability \u00b6 1. Update the Registry \u00b6 Add the capability to config/capabilities/index.yaml . Ensure the id follows the pattern domain.subdomain.action . 2. Validate Changes \u00b6 Run the CLI tool to ensure the registry is still valid: 1 ./scripts/capability-registry validate 3. Update Policy \u00b6 Grant permissions to the new capability in config/policy-workday.yaml . You can reference the full ID or use wildcards (e.g., workday.hcm.* ). 4. Cross-Validate Policy \u00b6 Ensure the policy correctly references existing capabilities: 1 ./scripts/capability-registry check-policy config/policy-workday.yaml Runtime Behavior \u00b6 Startup : The system cross-validates all policy files against the registry. If a policy references a non-existent capability, the application will fail to start. Execution : ActionService validates every request against the registry. Subdomain Expansion : If a domain is provided without a subdomain (e.g., workday.get_employee ), the system dynamically derives available subdomains from the registry to find the canonical match (e.g., workday.hcm.get_employee ). Deprecation : If a capability is marked as deprecated: true , it will still execute, but a warning will be logged. Visual Governance (Backstage) \u00b6 The Capability Registry is automatically synchronized with Backstage.io . This provides a web-based interface for: - Browsing capabilities by domain. - Viewing sensitivity and MFA requirements. - Identifying governing policies for each action. - Visualizing orchestration flows for composite capabilities. To synchronize changes manually: 1 python3 scripts/generate_catalog.py CLI Reference \u00b6 list : List all capabilities with optional filtering by --domain , --type , or --tag . validate : Check the registry file for schema errors or duplicate IDs. check-policy <file> : Validate a policy file against the registry. stats : Show distribution of capabilities by domain and type.","title":"Developer Guide: Capability Registry"},{"location":"CAPABILITY_REGISTRY/#developer-guide-capability-registry","text":"","title":"Developer Guide: Capability Registry"},{"location":"CAPABILITY_REGISTRY/#overview","text":"The Capability Registry is the central source of truth for all HR Platform capabilities (Actions and Flows). It ensures consistency between policy definitions, implementation logic, and runtime execution.","title":"Overview"},{"location":"CAPABILITY_REGISTRY/#file-structure","text":"Registry definitions are stored in a single YAML file: config/capabilities/index.yaml","title":"File Structure"},{"location":"CAPABILITY_REGISTRY/#example-entry","text":"1 2 3 4 5 6 7 - id : \"workday.hcm.get_employee\" name : \"Get Employee Profile\" domain : \"workday.hcm\" type : \"action\" sensitivity : \"medium\" tags : [ \"read-only\" , \"hcm\" , \"pii\" ] description : \"Retrieve basic public profile information for an employee\"","title":"Example Entry"},{"location":"CAPABILITY_REGISTRY/#adding-a-new-capability","text":"","title":"Adding a New Capability"},{"location":"CAPABILITY_REGISTRY/#1-update-the-registry","text":"Add the capability to config/capabilities/index.yaml . Ensure the id follows the pattern domain.subdomain.action .","title":"1. Update the Registry"},{"location":"CAPABILITY_REGISTRY/#2-validate-changes","text":"Run the CLI tool to ensure the registry is still valid: 1 ./scripts/capability-registry validate","title":"2. Validate Changes"},{"location":"CAPABILITY_REGISTRY/#3-update-policy","text":"Grant permissions to the new capability in config/policy-workday.yaml . You can reference the full ID or use wildcards (e.g., workday.hcm.* ).","title":"3. Update Policy"},{"location":"CAPABILITY_REGISTRY/#4-cross-validate-policy","text":"Ensure the policy correctly references existing capabilities: 1 ./scripts/capability-registry check-policy config/policy-workday.yaml","title":"4. Cross-Validate Policy"},{"location":"CAPABILITY_REGISTRY/#runtime-behavior","text":"Startup : The system cross-validates all policy files against the registry. If a policy references a non-existent capability, the application will fail to start. Execution : ActionService validates every request against the registry. Subdomain Expansion : If a domain is provided without a subdomain (e.g., workday.get_employee ), the system dynamically derives available subdomains from the registry to find the canonical match (e.g., workday.hcm.get_employee ). Deprecation : If a capability is marked as deprecated: true , it will still execute, but a warning will be logged.","title":"Runtime Behavior"},{"location":"CAPABILITY_REGISTRY/#visual-governance-backstage","text":"The Capability Registry is automatically synchronized with Backstage.io . This provides a web-based interface for: - Browsing capabilities by domain. - Viewing sensitivity and MFA requirements. - Identifying governing policies for each action. - Visualizing orchestration flows for composite capabilities. To synchronize changes manually: 1 python3 scripts/generate_catalog.py","title":"Visual Governance (Backstage)"},{"location":"CAPABILITY_REGISTRY/#cli-reference","text":"list : List all capabilities with optional filtering by --domain , --type , or --tag . validate : Check the registry file for schema errors or duplicate IDs. check-policy <file> : Validate a policy file against the registry. stats : Show distribution of capabilities by domain and type.","title":"CLI Reference"},{"location":"api_usage/","text":"API Usage Guide \u00b6 Getting Started \u00b6 1. Running the Server \u00b6 Start the API in development mode: 1 uvicorn src.main:app --reload The API will be available at http://localhost:8000 . Swagger documentation is at http://localhost:8000/docs . 2. Authentication \u00b6 The API is secured via OIDC. In local development, we use a MockOktaProvider that mimics real Okta behavior. Identify your Persona \u00b6 The permissions are tied to the sub (subject) claim in your token. Common subjects from the simulator fixtures: - admin@local.test : Full access (Requires MFA for some actions). - user@local.test (or EMP001 ): Standard employee access (Self-service only). - agent-assistant@local.test : AI Agent access (Filtered fields). Using Helper Scripts \u00b6 To simplify testing, several helper scripts are provided in scripts/api/ : - smoke-test.sh : Runs a suite of common scenarios. - run-action.sh : Executes a specific action for a persona. - get-token.sh : Obtains a raw token for a persona. Standard Request Pattern \u00b6 All actions follow a standard POST pattern to /actions/{domain}/{action} . Example Request: 1 2 3 4 curl -X POST http://localhost:8000/actions/workday.hcm/get_employee \\ -H \"Authorization: Bearer <YOUR_TOKEN_HERE>\" \\ -H \"Content-Type: application/json\" \\ -d '{\"parameters\": {\"employee_id\": \"EMP001\"}}' Advanced Authentication (MFA) \u00b6 For actions requiring MFA (like get_compensation or approve time-off), your token must include the amr: [\"mfa\"] claim. You can use the mock's admin endpoint to mint such a token (requires the test secret): 1 2 3 4 curl -X POST http://localhost:8000/auth/test/tokens \\ -H \"Content-Type: application/json\" \\ -H \"X-Test-Secret: mock-okta-secret\" \\ -d '{ \"subject\": \"admin@local.test\", \"additional_claims\": { \"amr\": [\"mfa\", \"pwd\"] } }'","title":"API Usage Guide"},{"location":"api_usage/#api-usage-guide","text":"","title":"API Usage Guide"},{"location":"api_usage/#getting-started","text":"","title":"Getting Started"},{"location":"api_usage/#1-running-the-server","text":"Start the API in development mode: 1 uvicorn src.main:app --reload The API will be available at http://localhost:8000 . Swagger documentation is at http://localhost:8000/docs .","title":"1. Running the Server"},{"location":"api_usage/#2-authentication","text":"The API is secured via OIDC. In local development, we use a MockOktaProvider that mimics real Okta behavior.","title":"2. Authentication"},{"location":"api_usage/#identify-your-persona","text":"The permissions are tied to the sub (subject) claim in your token. Common subjects from the simulator fixtures: - admin@local.test : Full access (Requires MFA for some actions). - user@local.test (or EMP001 ): Standard employee access (Self-service only). - agent-assistant@local.test : AI Agent access (Filtered fields).","title":"Identify your Persona"},{"location":"api_usage/#using-helper-scripts","text":"To simplify testing, several helper scripts are provided in scripts/api/ : - smoke-test.sh : Runs a suite of common scenarios. - run-action.sh : Executes a specific action for a persona. - get-token.sh : Obtains a raw token for a persona.","title":"Using Helper Scripts"},{"location":"api_usage/#standard-request-pattern","text":"All actions follow a standard POST pattern to /actions/{domain}/{action} . Example Request: 1 2 3 4 curl -X POST http://localhost:8000/actions/workday.hcm/get_employee \\ -H \"Authorization: Bearer <YOUR_TOKEN_HERE>\" \\ -H \"Content-Type: application/json\" \\ -d '{\"parameters\": {\"employee_id\": \"EMP001\"}}'","title":"Standard Request Pattern"},{"location":"api_usage/#advanced-authentication-mfa","text":"For actions requiring MFA (like get_compensation or approve time-off), your token must include the amr: [\"mfa\"] claim. You can use the mock's admin endpoint to mint such a token (requires the test secret): 1 2 3 4 curl -X POST http://localhost:8000/auth/test/tokens \\ -H \"Content-Type: application/json\" \\ -H \"X-Test-Secret: mock-okta-secret\" \\ -d '{ \"subject\": \"admin@local.test\", \"additional_claims\": { \"amr\": [\"mfa\", \"pwd\"] } }'","title":"Advanced Authentication (MFA)"},{"location":"architecture/","text":"Architectural Guide: Capability API \u00b6 This document provides a high-level overview of the HR AI Platform's Capability API system design. System Context (C4 Level 1) \u00b6 The Capability API serves as the central orchestration layer between AI Agents/HR Applications and external HR systems like Workday. C4Context title System Context diagram for Capability API Person(agent, \"AI Agent\", \"Automated reasoning engine requesting HR actions\") Person(admin, \"HR Admin\", \"Human user managing policies and workflows\") System(capapi, \"Capability API\", \"Governed surface exposing deterministic actions and flows\") System(backstage, \"Backstage\", \"Governance lens and catalog\") System_Ext(workday, \"Workday\", \"Core HRIS containing employee and payroll records\") System_Ext(okta, \"Okta\", \"Identity Provider for OIDC authentication\") Rel(agent, capapi, \"Invokes Actions/Flows\", \"HTTPS/JSON + JWT\") Rel(admin, capapi, \"Manages Policies\", \"YAML/CLI\") Rel(admin, backstage, \"Inspects Governance\", \"HTTPS/Web\") Rel(capapi, workday, \"Integrates with\", \"REST API\") Rel(capapi, okta, \"Validates Tokens against\", \"JWKS\") Rel(backstage, capapi, \"Reads Metadata\", \"Git/YAML\") Containers (C4 Level 2) \u00b6 The system follows a Hexagonal Architecture (Ports and Adapters) to ensure the core business logic remains isolated from infrastructure concerns. C4Container title Container diagram for Capability API Container_Boundary(api_boundary, \"API Layer\") { Container(routes, \"API Routes\", \"FastAPI\", \"Request handling and Auth injection\") } Container_Boundary(core_boundary, \"Protected Domain Core\") { Container(action_service, \"Action Service\", \"Python\", \"Policy evaluation and action routing\") Container(flow_service, \"Flow Service\", \"Python\", \"Workflow orchestration\") Container(policy_engine, \"Policy Engine\", \"Python\", \"Capability-based authorization logic\") } Container_Boundary(adapter_boundary, \"Implementation Adapters\") { Container(workday_adapter, \"Workday Adapter\", \"Python\", \"Simulated or Real Workday connector\") Container(auth_adapter, \"Auth Adapter\", \"Python\", \"Token verification logic\") Container(fs_adapter, \"Filesystem Adapter\", \"Python\", \"Local storage for policies and flows\") Container(mcp_server, \"HR MCP Server\", \"FastMCP 3.0\", \"AI-agent gateway with RBAC\") } Container(backstage, \"Backstage\", \"Backstage.io\", \"Visualizes catalog and verification reports\") Rel(mcp_server, routes, \"Invokes\", \"HTTPS/JSON\") Rel(routes, action_service, \"Calls\", \"Internal\") Rel(routes, flow_service, \"Calls\", \"Internal\") Rel(action_service, policy_engine, \"Uses\", \"Logic\") Rel(action_service, workday_adapter, \"Uses\", \"Connector Port\") Rel(flow_service, fs_adapter, \"Uses\", \"Flow Runner Port\") Rel(routes, auth_adapter, \"Uses\", \"Token Verifier Port\") Rel(backstage, fs_adapter, \"Reads catalog-info.yaml\", \"Static Files\") Port & Adapter Mappings \u00b6 Port (Interface) Adapter (Implementation) Purpose ConnectorPort WorkdaySimulator External HR system integration FlowRunnerPort LocalFlowRunnerAdapter Long-running process execution PolicyLoaderPort FilePolicyLoaderAdapter Policy document persistence TokenVerifier MockTokenVerifier Identity validation Module Documentation \u00b6 For detailed information on specific system components, refer to the following module guides: API Layer : Entry points, routing, and dependencies. Domain Entities : Core data models and audit protocols. Auth Adapter : OIDC simulation and token verification. Workday Simulator : Simulated HRIS implementation (HCM, Time, Payroll). Filesystem Adapter : Policy loading and flow execution. Policy Verification : Declarative security testing and compliance reporting. Backstage Integration : Governance lens and capability catalog. Core Principles \u00b6 The Sanctuary : The domain/ directory MUST NOT import from adapters/ or api/ . Deterministic Actions : All actions must have explicit Pydantic schemas and predictable outcomes. Audit by Design : Every operation generates provenance metadata tracked via the ActionResponse .","title":"Architecture"},{"location":"architecture/#architectural-guide-capability-api","text":"This document provides a high-level overview of the HR AI Platform's Capability API system design.","title":"Architectural Guide: Capability API"},{"location":"architecture/#system-context-c4-level-1","text":"The Capability API serves as the central orchestration layer between AI Agents/HR Applications and external HR systems like Workday. C4Context title System Context diagram for Capability API Person(agent, \"AI Agent\", \"Automated reasoning engine requesting HR actions\") Person(admin, \"HR Admin\", \"Human user managing policies and workflows\") System(capapi, \"Capability API\", \"Governed surface exposing deterministic actions and flows\") System(backstage, \"Backstage\", \"Governance lens and catalog\") System_Ext(workday, \"Workday\", \"Core HRIS containing employee and payroll records\") System_Ext(okta, \"Okta\", \"Identity Provider for OIDC authentication\") Rel(agent, capapi, \"Invokes Actions/Flows\", \"HTTPS/JSON + JWT\") Rel(admin, capapi, \"Manages Policies\", \"YAML/CLI\") Rel(admin, backstage, \"Inspects Governance\", \"HTTPS/Web\") Rel(capapi, workday, \"Integrates with\", \"REST API\") Rel(capapi, okta, \"Validates Tokens against\", \"JWKS\") Rel(backstage, capapi, \"Reads Metadata\", \"Git/YAML\")","title":"System Context (C4 Level 1)"},{"location":"architecture/#containers-c4-level-2","text":"The system follows a Hexagonal Architecture (Ports and Adapters) to ensure the core business logic remains isolated from infrastructure concerns. C4Container title Container diagram for Capability API Container_Boundary(api_boundary, \"API Layer\") { Container(routes, \"API Routes\", \"FastAPI\", \"Request handling and Auth injection\") } Container_Boundary(core_boundary, \"Protected Domain Core\") { Container(action_service, \"Action Service\", \"Python\", \"Policy evaluation and action routing\") Container(flow_service, \"Flow Service\", \"Python\", \"Workflow orchestration\") Container(policy_engine, \"Policy Engine\", \"Python\", \"Capability-based authorization logic\") } Container_Boundary(adapter_boundary, \"Implementation Adapters\") { Container(workday_adapter, \"Workday Adapter\", \"Python\", \"Simulated or Real Workday connector\") Container(auth_adapter, \"Auth Adapter\", \"Python\", \"Token verification logic\") Container(fs_adapter, \"Filesystem Adapter\", \"Python\", \"Local storage for policies and flows\") Container(mcp_server, \"HR MCP Server\", \"FastMCP 3.0\", \"AI-agent gateway with RBAC\") } Container(backstage, \"Backstage\", \"Backstage.io\", \"Visualizes catalog and verification reports\") Rel(mcp_server, routes, \"Invokes\", \"HTTPS/JSON\") Rel(routes, action_service, \"Calls\", \"Internal\") Rel(routes, flow_service, \"Calls\", \"Internal\") Rel(action_service, policy_engine, \"Uses\", \"Logic\") Rel(action_service, workday_adapter, \"Uses\", \"Connector Port\") Rel(flow_service, fs_adapter, \"Uses\", \"Flow Runner Port\") Rel(routes, auth_adapter, \"Uses\", \"Token Verifier Port\") Rel(backstage, fs_adapter, \"Reads catalog-info.yaml\", \"Static Files\")","title":"Containers (C4 Level 2)"},{"location":"architecture/#port-adapter-mappings","text":"Port (Interface) Adapter (Implementation) Purpose ConnectorPort WorkdaySimulator External HR system integration FlowRunnerPort LocalFlowRunnerAdapter Long-running process execution PolicyLoaderPort FilePolicyLoaderAdapter Policy document persistence TokenVerifier MockTokenVerifier Identity validation","title":"Port &amp; Adapter Mappings"},{"location":"architecture/#module-documentation","text":"For detailed information on specific system components, refer to the following module guides: API Layer : Entry points, routing, and dependencies. Domain Entities : Core data models and audit protocols. Auth Adapter : OIDC simulation and token verification. Workday Simulator : Simulated HRIS implementation (HCM, Time, Payroll). Filesystem Adapter : Policy loading and flow execution. Policy Verification : Declarative security testing and compliance reporting. Backstage Integration : Governance lens and capability catalog.","title":"Module Documentation"},{"location":"architecture/#core-principles","text":"The Sanctuary : The domain/ directory MUST NOT import from adapters/ or api/ . Deterministic Actions : All actions must have explicit Pydantic schemas and predictable outcomes. Audit by Design : Every operation generates provenance metadata tracked via the ActionResponse .","title":"Core Principles"},{"location":"backstage/","text":"Backstage.io Governance Integration \u00b6 Overview \u00b6 The HR AI Platform integrates with Backstage.io to provide a \"read-only governance lens\" over the Capability API. This integration ensures that the platform's security posture, capability inventory, and compliance status are visible to non-technical stakeholders without changing the underlying enforcement model. The integration consists of two main initiatives: 1. Capability Catalog : A browsable inventory of all Actions and Flows. 2. Policy Verification Dashboard : An interactive report of security test results. 1. Capability Catalog \u00b6 The Capability Catalog transforms our internal index.yaml definitions into Backstage API entities. This allows stakeholders to browse capabilities by domain, check sensitivity levels, and see which policies govern each action. Key Features \u00b6 Domain Grouping : Capabilities are organized into Backstage Systems (e.g., workday-hcm , workday-payroll ). Sensitivity Badges : Visual indicators for low , medium , high , and critical data sensitivity. MFA Indicators : Clearly marks capabilities that require Multi-Factor Authentication. Policy Cross-Reference : Each entity page includes a \"Governed By\" section listing the exact policies that grant access to it. Implementation Flows : Composite capabilities include visualized Mermaid diagrams showing their orchestration logic. Catalog Generation \u00b6 The catalog is generated via a build-time script: 1 python3 scripts/generate_catalog.py This script is executed in CI to ensure the Backstage view never diverges from the Git-committed configuration. 2. Policy Verification Dashboard \u00b6 The Verification Dashboard provides a web-accessible view of the platform's access policy behavior. It is published as a Backstage TechDocs page. Features \u00b6 Pass/Fail Metrics : High-level summary of policy test scenarios. Detailed Results : A sortable table of all 107+ test cases, showing matched policies and execution times. Staleness Detection : The report includes a timestamp and is updated automatically on every policy change. Accessing the Dashboard \u00b6 In Backstage, navigate to the Capability API component and select the Docs tab. The dashboard is located under the Governance section in the sidebar. 3. Getting Started \u00b6 Prerequisites \u00b6 Node.js : Version 18 or 20. Yarn : Classic ( 1.x ). Docker : Required for running TechDocs locally and some plugins. Installation \u00b6 If you don't have a Backstage instance, you can create a new one: 1 npx @backstage/create-app@latest Follow the prompts to name your app and select the database (SQLite is easiest for local testing). Configuring this Repository \u00b6 To see the Capability API governance data in your Backstage instance, you need to register the root catalog-info.yaml file. Generate the Catalog : 1 2 python3 scripts/generate_catalog.py ./scripts/verify-policy run Register in Backstage (Local Development) : Since the Backstage UI often blocks file:// paths for security, the recommended way to register local files is by adding them to your app-config.yaml : 1 2 3 4 5 # In your Backstage project's app-config.yaml catalog : locations : - type : file target : /absolute/path/to/capability_API/catalog-info.yaml Register in Backstage (Production) : Once your code is pushed to a Git provider (GitHub, GitLab, etc.), you can use the URL to the file in the UI: - Open Backstage (e.g., http://localhost:3000 ). - Click Register Existing Component . - Enter the URL: https://github.com/your-org/capability_API/blob/main/catalog-info.yaml TechDocs Setup \u00b6 To view the verification reports locally, ensure you have the mkdocs and mkdocs-techdocs-core plugin installed, or use the Backstage CLI to preview: 1 npx @backstage/cli techdocs-cli preview --storage-name local 4. Continuous Sync (CI/CD) \u00b6 Governance visibility is enforced through our GitHub Actions workflows: - Sync Check : PRs are blocked if the catalog entities in catalog/ are out of sync with config/capabilities/index.yaml . - Automatic Publishing : The verification report is regenerated and published to TechDocs on every merge to main . Developer Reference \u00b6 Root Configuration : catalog-info.yaml (Defines the Component, Systems, and Locations) Generator Script : scripts/generate_catalog.py Verifier Script : scripts/verify-policy Templates : scripts/templates/ TechDocs Home : docs/index.md TechDocs Output : docs/policy-verification/latest.md Configuration : mkdocs.yml","title":"Backstage.io Governance Integration"},{"location":"backstage/#backstageio-governance-integration","text":"","title":"Backstage.io Governance Integration"},{"location":"backstage/#overview","text":"The HR AI Platform integrates with Backstage.io to provide a \"read-only governance lens\" over the Capability API. This integration ensures that the platform's security posture, capability inventory, and compliance status are visible to non-technical stakeholders without changing the underlying enforcement model. The integration consists of two main initiatives: 1. Capability Catalog : A browsable inventory of all Actions and Flows. 2. Policy Verification Dashboard : An interactive report of security test results.","title":"Overview"},{"location":"backstage/#1-capability-catalog","text":"The Capability Catalog transforms our internal index.yaml definitions into Backstage API entities. This allows stakeholders to browse capabilities by domain, check sensitivity levels, and see which policies govern each action.","title":"1. Capability Catalog"},{"location":"backstage/#key-features","text":"Domain Grouping : Capabilities are organized into Backstage Systems (e.g., workday-hcm , workday-payroll ). Sensitivity Badges : Visual indicators for low , medium , high , and critical data sensitivity. MFA Indicators : Clearly marks capabilities that require Multi-Factor Authentication. Policy Cross-Reference : Each entity page includes a \"Governed By\" section listing the exact policies that grant access to it. Implementation Flows : Composite capabilities include visualized Mermaid diagrams showing their orchestration logic.","title":"Key Features"},{"location":"backstage/#catalog-generation","text":"The catalog is generated via a build-time script: 1 python3 scripts/generate_catalog.py This script is executed in CI to ensure the Backstage view never diverges from the Git-committed configuration.","title":"Catalog Generation"},{"location":"backstage/#2-policy-verification-dashboard","text":"The Verification Dashboard provides a web-accessible view of the platform's access policy behavior. It is published as a Backstage TechDocs page.","title":"2. Policy Verification Dashboard"},{"location":"backstage/#features","text":"Pass/Fail Metrics : High-level summary of policy test scenarios. Detailed Results : A sortable table of all 107+ test cases, showing matched policies and execution times. Staleness Detection : The report includes a timestamp and is updated automatically on every policy change.","title":"Features"},{"location":"backstage/#accessing-the-dashboard","text":"In Backstage, navigate to the Capability API component and select the Docs tab. The dashboard is located under the Governance section in the sidebar.","title":"Accessing the Dashboard"},{"location":"backstage/#3-getting-started","text":"","title":"3. Getting Started"},{"location":"backstage/#prerequisites","text":"Node.js : Version 18 or 20. Yarn : Classic ( 1.x ). Docker : Required for running TechDocs locally and some plugins.","title":"Prerequisites"},{"location":"backstage/#installation","text":"If you don't have a Backstage instance, you can create a new one: 1 npx @backstage/create-app@latest Follow the prompts to name your app and select the database (SQLite is easiest for local testing).","title":"Installation"},{"location":"backstage/#configuring-this-repository","text":"To see the Capability API governance data in your Backstage instance, you need to register the root catalog-info.yaml file. Generate the Catalog : 1 2 python3 scripts/generate_catalog.py ./scripts/verify-policy run Register in Backstage (Local Development) : Since the Backstage UI often blocks file:// paths for security, the recommended way to register local files is by adding them to your app-config.yaml : 1 2 3 4 5 # In your Backstage project's app-config.yaml catalog : locations : - type : file target : /absolute/path/to/capability_API/catalog-info.yaml Register in Backstage (Production) : Once your code is pushed to a Git provider (GitHub, GitLab, etc.), you can use the URL to the file in the UI: - Open Backstage (e.g., http://localhost:3000 ). - Click Register Existing Component . - Enter the URL: https://github.com/your-org/capability_API/blob/main/catalog-info.yaml","title":"Configuring this Repository"},{"location":"backstage/#techdocs-setup","text":"To view the verification reports locally, ensure you have the mkdocs and mkdocs-techdocs-core plugin installed, or use the Backstage CLI to preview: 1 npx @backstage/cli techdocs-cli preview --storage-name local","title":"TechDocs Setup"},{"location":"backstage/#4-continuous-sync-cicd","text":"Governance visibility is enforced through our GitHub Actions workflows: - Sync Check : PRs are blocked if the catalog entities in catalog/ are out of sync with config/capabilities/index.yaml . - Automatic Publishing : The verification report is regenerated and published to TechDocs on every merge to main .","title":"4. Continuous Sync (CI/CD)"},{"location":"backstage/#developer-reference","text":"Root Configuration : catalog-info.yaml (Defines the Component, Systems, and Locations) Generator Script : scripts/generate_catalog.py Verifier Script : scripts/verify-policy Templates : scripts/templates/ TechDocs Home : docs/index.md TechDocs Output : docs/policy-verification/latest.md Configuration : mkdocs.yml","title":"Developer Reference"},{"location":"governance/","text":"Governance Framework \u00b6 The HR AI Platform implements a comprehensive governance framework to ensure secure, compliant, and auditable AI-to-Workday operations. Overview \u00b6 Our governance model is built on three pillars: Policy-Driven Access Control : All capability access is governed by explicit YAML policies that define who can do what, under which conditions. Continuous Verification : Automated security testing ensures policies behave as intended across all scenarios. Audit Transparency : Every action generates immutable audit logs with full provenance tracking. Key Resources \u00b6 Policy Verification Dashboard \u00b6 The Policy Verification Dashboard provides real-time visibility into our security posture. It includes: - Pass/fail metrics for all policy scenarios - Detailed test results with execution times - Timestamp and policy version tracking - Coverage across Admin, Employee, AI Agent, and HR Staff personas This dashboard is automatically regenerated on every policy change to ensure stakeholders always see the current state. Policy Schema & Rules \u00b6 Our Policy Schema documentation defines the authoritative access control model: - Allow-list only approach (deny by default) - Principal resolution order (specific > group > type) - Wildcard matching semantics - Condition evaluation logic Security Architecture \u00b6 The Security Architecture document explains our defense-in-depth strategy: - Layer 1: Centralized Policy Engine & MCP Gateway - Layer 2: Service-Level Validation - Layer 3: Data Filtering & PII Protection Compliance & Auditing \u00b6 Access Control Principles \u00b6 Least Privilege : Principals only receive the minimum capabilities needed for their role Multi-Factor Authentication : High-sensitivity operations (compensation, personal data updates) require MFA Environment Isolation : Dev grants never apply in production Explicit Grants : No implicit permissions or default-allow rules Audit Trail \u00b6 Every capability invocation is logged with: - Principal identity (subject/group/type) - Capability identifier - UTC timestamp - Matched policy name - Request/response metadata (with PII redacted) Continuous Testing \u00b6 Changes to config/policy-workday.yaml must pass the verification suite before deployment: 1 ./scripts/verify-policy run New capabilities or roles require corresponding test scenarios in tests/policy/scenarios/ . Governance Visibility in Backstage \u00b6 The Backstage integration provides a read-only governance lens: - Capability Catalog : Browse all actions and flows with sensitivity labels - Policy Verification : View security test results - Entity Relationships : See which policies govern each capability See the Backstage Integration Guide for setup details. For Developers \u00b6 API Usage Guide : How to invoke capabilities with proper authentication Onboarding Guide : Getting started as a developer or consumer Troubleshooting : Common issues and solutions For Compliance Officers \u00b6 Navigate to the Policy Verification Dashboard to review current security test results Review the Security Architecture for defense-in-depth controls Check the Policy Schema for access control rules Last Updated : Auto-generated from Git repository Policy Verification : View Latest Results","title":"Governance"},{"location":"governance/#governance-framework","text":"The HR AI Platform implements a comprehensive governance framework to ensure secure, compliant, and auditable AI-to-Workday operations.","title":"Governance Framework"},{"location":"governance/#overview","text":"Our governance model is built on three pillars: Policy-Driven Access Control : All capability access is governed by explicit YAML policies that define who can do what, under which conditions. Continuous Verification : Automated security testing ensures policies behave as intended across all scenarios. Audit Transparency : Every action generates immutable audit logs with full provenance tracking.","title":"Overview"},{"location":"governance/#key-resources","text":"","title":"Key Resources"},{"location":"governance/#policy-verification-dashboard","text":"The Policy Verification Dashboard provides real-time visibility into our security posture. It includes: - Pass/fail metrics for all policy scenarios - Detailed test results with execution times - Timestamp and policy version tracking - Coverage across Admin, Employee, AI Agent, and HR Staff personas This dashboard is automatically regenerated on every policy change to ensure stakeholders always see the current state.","title":"Policy Verification Dashboard"},{"location":"governance/#policy-schema-rules","text":"Our Policy Schema documentation defines the authoritative access control model: - Allow-list only approach (deny by default) - Principal resolution order (specific > group > type) - Wildcard matching semantics - Condition evaluation logic","title":"Policy Schema &amp; Rules"},{"location":"governance/#security-architecture","text":"The Security Architecture document explains our defense-in-depth strategy: - Layer 1: Centralized Policy Engine & MCP Gateway - Layer 2: Service-Level Validation - Layer 3: Data Filtering & PII Protection","title":"Security Architecture"},{"location":"governance/#compliance-auditing","text":"","title":"Compliance &amp; Auditing"},{"location":"governance/#access-control-principles","text":"Least Privilege : Principals only receive the minimum capabilities needed for their role Multi-Factor Authentication : High-sensitivity operations (compensation, personal data updates) require MFA Environment Isolation : Dev grants never apply in production Explicit Grants : No implicit permissions or default-allow rules","title":"Access Control Principles"},{"location":"governance/#audit-trail","text":"Every capability invocation is logged with: - Principal identity (subject/group/type) - Capability identifier - UTC timestamp - Matched policy name - Request/response metadata (with PII redacted)","title":"Audit Trail"},{"location":"governance/#continuous-testing","text":"Changes to config/policy-workday.yaml must pass the verification suite before deployment: 1 ./scripts/verify-policy run New capabilities or roles require corresponding test scenarios in tests/policy/scenarios/ .","title":"Continuous Testing"},{"location":"governance/#governance-visibility-in-backstage","text":"The Backstage integration provides a read-only governance lens: - Capability Catalog : Browse all actions and flows with sensitivity labels - Policy Verification : View security test results - Entity Relationships : See which policies govern each capability See the Backstage Integration Guide for setup details.","title":"Governance Visibility in Backstage"},{"location":"governance/#for-developers","text":"API Usage Guide : How to invoke capabilities with proper authentication Onboarding Guide : Getting started as a developer or consumer Troubleshooting : Common issues and solutions","title":"For Developers"},{"location":"governance/#for-compliance-officers","text":"Navigate to the Policy Verification Dashboard to review current security test results Review the Security Architecture for defense-in-depth controls Check the Policy Schema for access control rules Last Updated : Auto-generated from Git repository Policy Verification : View Latest Results","title":"For Compliance Officers"},{"location":"motivation/","text":"Why We are Building the Capability API: The Trust Layer for HR AI \u00b6 The Big Picture \u00b6 In most companies today, HR processes are fragmented. Employee data lives in complex systems like Workday, payroll runs in another, and requests for time off or onboarding are handled through a mix of emails, tickets, and spreadsheets. As we introduce AI Agents (like Claude or Gemini) to help employees and managers navigate these systems, we face a major challenge: How do we let a robot handle sensitive data without risking a massive security breach? We are building the Capability API: a single, secure gateway that acts as a \"Trust Layer\" between AI and our most sensitive human data. The Five Pillars of Our Solution \u00b6 To make AI safe for HR, we\u2019ve built five integrated components that work together to ensure security, safety, and transparency. 1. The Capability API (The Orchestrator) \u00b6 This is the \"Universal Remote Control\" for HR. Instead of letting every app or AI agent talk directly to our databases, they all talk to this API. It ensures that every action is performed consistently, regardless of whether a human or a robot triggered it. 2. The Workday Simulator (The Safety Playground) \u00b6 We can't just \"test\" our AI on real employee salary data. Our Simulator is a high-fidelity, virtual copy of our HR system. it allows developers and AI to practice submitting time-off requests or viewing org charts in a 100% safe environment with synthetic data. 3. Okta Auth & Token Exchange (The Identity Guard) \u00b6 We use industry-standard security (Okta) to verify exactly who is making a request. For AI agents, we use a specialized process called Token Exchange . This gives the AI a \"temporary pass\" that lasts only 5 minutes and is limited to very specific tasks, ensuring that even if an AI is compromised, the \"blast radius\" is tiny. 4. MCP Servers (The AI Bridge) \u00b6 AI models need a way to \"see\" and \"use\" HR tools. Our MCP (Model Context Protocol) Servers act as the bridge. They translate the complex language of HR systems into simple \"tools\" that an AI can understand, while simultaneously enforcing our strict security rules\u2014including full JWT signature verification\u2014at the very edge where the AI operates. 5. Policy Verification (The Safety Net) \u00b6 Security rules are written in a master file (Policy YAML). However, humans can make mistakes when writing these rules. Our Policy Verification Framework mathematically proves our security rules work as intended before they go live. It prevents \"silent security holes\" by automatically testing 100+ scenarios every time a rule is changed. 6. Backstage Governance (The Transparent Lens) \u00b6 Governance is useless if it's invisible. Our Backstage Integration provides a browsable, human-friendly view of the entire platform. it allows non-technical stakeholders to see every capability, its sensitivity, and the exact policy that governs it, ensuring the \"Trust Layer\" is verifiable by everyone in the company. Why This Matters to the Business \u00b6 Zero Trust Security : We never assume an AI agent is safe. Every request is verified. If the policy doesn't explicitly say \"Yes,\" the answer is \"No.\" Continuous Compliance : We generate audit-ready reports that prove to regulators and security teams that we are enforcing least-privilege access at all times. Audit Trail & Provenance : We log everything. If an AI agent performs an action, our logs show exactly which AI did it, which user it was helping, and which security rule allowed it. Agility with Safety : We can launch new AI features in days instead of months because the \"Trust Layer\" handles the hard security work for us. What to Expect in a Demo \u00b6 When you see a demo of this system, you are seeing governance in action : The AI Guardrail : An AI assistant helps an employee check their PTO balance (Allowed), but is instantly blocked if it tries to peek at a colleague's payroll (Denied). Scoped AI Access : You'll see the AI get a \"short-term pass\" to do its job, which automatically expires, leaving no permanent access behind. The Policy Safety Net : You'll see a developer try to accidentally give an AI agent too much power, only to have the system block the commit and demand a correction. Transparent Reporting : You'll see a clean report that proves our system is 100% compliant with our security requirements (SEC-001 through SEC-005). Summary \u00b6 We aren't just writing code to move data; we are building the trust infrastructure that allows our company to safely use AI in the most sensitive area of our business: our people.","title":"Why We are Building the Capability API: The Trust Layer for HR AI"},{"location":"motivation/#why-we-are-building-the-capability-api-the-trust-layer-for-hr-ai","text":"","title":"Why We are Building the Capability API: The Trust Layer for HR AI"},{"location":"motivation/#the-big-picture","text":"In most companies today, HR processes are fragmented. Employee data lives in complex systems like Workday, payroll runs in another, and requests for time off or onboarding are handled through a mix of emails, tickets, and spreadsheets. As we introduce AI Agents (like Claude or Gemini) to help employees and managers navigate these systems, we face a major challenge: How do we let a robot handle sensitive data without risking a massive security breach? We are building the Capability API: a single, secure gateway that acts as a \"Trust Layer\" between AI and our most sensitive human data.","title":"The Big Picture"},{"location":"motivation/#the-five-pillars-of-our-solution","text":"To make AI safe for HR, we\u2019ve built five integrated components that work together to ensure security, safety, and transparency.","title":"The Five Pillars of Our Solution"},{"location":"motivation/#1-the-capability-api-the-orchestrator","text":"This is the \"Universal Remote Control\" for HR. Instead of letting every app or AI agent talk directly to our databases, they all talk to this API. It ensures that every action is performed consistently, regardless of whether a human or a robot triggered it.","title":"1. The Capability API (The Orchestrator)"},{"location":"motivation/#2-the-workday-simulator-the-safety-playground","text":"We can't just \"test\" our AI on real employee salary data. Our Simulator is a high-fidelity, virtual copy of our HR system. it allows developers and AI to practice submitting time-off requests or viewing org charts in a 100% safe environment with synthetic data.","title":"2. The Workday Simulator (The Safety Playground)"},{"location":"motivation/#3-okta-auth-token-exchange-the-identity-guard","text":"We use industry-standard security (Okta) to verify exactly who is making a request. For AI agents, we use a specialized process called Token Exchange . This gives the AI a \"temporary pass\" that lasts only 5 minutes and is limited to very specific tasks, ensuring that even if an AI is compromised, the \"blast radius\" is tiny.","title":"3. Okta Auth &amp; Token Exchange (The Identity Guard)"},{"location":"motivation/#4-mcp-servers-the-ai-bridge","text":"AI models need a way to \"see\" and \"use\" HR tools. Our MCP (Model Context Protocol) Servers act as the bridge. They translate the complex language of HR systems into simple \"tools\" that an AI can understand, while simultaneously enforcing our strict security rules\u2014including full JWT signature verification\u2014at the very edge where the AI operates.","title":"4. MCP Servers (The AI Bridge)"},{"location":"motivation/#5-policy-verification-the-safety-net","text":"Security rules are written in a master file (Policy YAML). However, humans can make mistakes when writing these rules. Our Policy Verification Framework mathematically proves our security rules work as intended before they go live. It prevents \"silent security holes\" by automatically testing 100+ scenarios every time a rule is changed.","title":"5. Policy Verification (The Safety Net)"},{"location":"motivation/#6-backstage-governance-the-transparent-lens","text":"Governance is useless if it's invisible. Our Backstage Integration provides a browsable, human-friendly view of the entire platform. it allows non-technical stakeholders to see every capability, its sensitivity, and the exact policy that governs it, ensuring the \"Trust Layer\" is verifiable by everyone in the company.","title":"6. Backstage Governance (The Transparent Lens)"},{"location":"motivation/#why-this-matters-to-the-business","text":"Zero Trust Security : We never assume an AI agent is safe. Every request is verified. If the policy doesn't explicitly say \"Yes,\" the answer is \"No.\" Continuous Compliance : We generate audit-ready reports that prove to regulators and security teams that we are enforcing least-privilege access at all times. Audit Trail & Provenance : We log everything. If an AI agent performs an action, our logs show exactly which AI did it, which user it was helping, and which security rule allowed it. Agility with Safety : We can launch new AI features in days instead of months because the \"Trust Layer\" handles the hard security work for us.","title":"Why This Matters to the Business"},{"location":"motivation/#what-to-expect-in-a-demo","text":"When you see a demo of this system, you are seeing governance in action : The AI Guardrail : An AI assistant helps an employee check their PTO balance (Allowed), but is instantly blocked if it tries to peek at a colleague's payroll (Denied). Scoped AI Access : You'll see the AI get a \"short-term pass\" to do its job, which automatically expires, leaving no permanent access behind. The Policy Safety Net : You'll see a developer try to accidentally give an AI agent too much power, only to have the system block the commit and demand a correction. Transparent Reporting : You'll see a clean report that proves our system is 100% compliant with our security requirements (SEC-001 through SEC-005).","title":"What to Expect in a Demo"},{"location":"motivation/#summary","text":"We aren't just writing code to move data; we are building the trust infrastructure that allows our company to safely use AI in the most sensitive area of our business: our people.","title":"Summary"},{"location":"onboarding/","text":"Developer Onboarding Guide \u00b6 Welcome to the Capability API project! This guide will help you set up your local development environment. Prerequisites \u00b6 Python : 3.11 or higher. Git : For version control. Setup Instructions \u00b6 1. Clone the Repository \u00b6 1 2 git clone <repo-url> cd capability_API 2. Create a Virtual Environment \u00b6 1 2 python3 -m venv .venv source .venv/bin/activate 3. Install Dependencies \u00b6 1 pip install -r requirements.txt 4. Configuration \u00b6 Create a .env file based on .env.example : 1 cp .env.example .env Ensure POLICY_PATH points to config/policy-workday.yaml for local development. 5. Running the API \u00b6 1 python -m src.main The API will be available at http://localhost:8000 . You can view the interactive documentation at http://localhost:8000/docs . Environment Flags \u00b6 ENVIRONMENT : local | dev | prod | test POLICY_PATH : config/policy-workday.yaml (default) MOCK_OKTA_TEST_SECRET : Secret key for mock Okta test endpoints (default: mock-okta-secret ). ENABLE_DEMO_RESET : true | false (mounts demo reset endpoint; local only) Running Tests \u00b6 We use pytest for all tests. 1 2 3 4 5 # Quick tests (unit only) pytest tests/unit/ # Run all tests pytest Governance & Documentation \u00b6 If you modify the Capability Registry ( config/capabilities/index.yaml ), you must regenerate the Backstage catalog: 1 python3 scripts/generate_catalog.py To view the local governance docs (requires MkDocs): 1 mkdocs serve Key Documentation to Read \u00b6 Architecture : docs/architecture.md Backstage Integration : docs/backstage.md API Usage : docs/api_usage.md Constitution : .specify/memory/constitution.md","title":"Onboarding"},{"location":"onboarding/#developer-onboarding-guide","text":"Welcome to the Capability API project! This guide will help you set up your local development environment.","title":"Developer Onboarding Guide"},{"location":"onboarding/#prerequisites","text":"Python : 3.11 or higher. Git : For version control.","title":"Prerequisites"},{"location":"onboarding/#setup-instructions","text":"","title":"Setup Instructions"},{"location":"onboarding/#1-clone-the-repository","text":"1 2 git clone <repo-url> cd capability_API","title":"1. Clone the Repository"},{"location":"onboarding/#2-create-a-virtual-environment","text":"1 2 python3 -m venv .venv source .venv/bin/activate","title":"2. Create a Virtual Environment"},{"location":"onboarding/#3-install-dependencies","text":"1 pip install -r requirements.txt","title":"3. Install Dependencies"},{"location":"onboarding/#4-configuration","text":"Create a .env file based on .env.example : 1 cp .env.example .env Ensure POLICY_PATH points to config/policy-workday.yaml for local development.","title":"4. Configuration"},{"location":"onboarding/#5-running-the-api","text":"1 python -m src.main The API will be available at http://localhost:8000 . You can view the interactive documentation at http://localhost:8000/docs .","title":"5. Running the API"},{"location":"onboarding/#environment-flags","text":"ENVIRONMENT : local | dev | prod | test POLICY_PATH : config/policy-workday.yaml (default) MOCK_OKTA_TEST_SECRET : Secret key for mock Okta test endpoints (default: mock-okta-secret ). ENABLE_DEMO_RESET : true | false (mounts demo reset endpoint; local only)","title":"Environment Flags"},{"location":"onboarding/#running-tests","text":"We use pytest for all tests. 1 2 3 4 5 # Quick tests (unit only) pytest tests/unit/ # Run all tests pytest","title":"Running Tests"},{"location":"onboarding/#governance-documentation","text":"If you modify the Capability Registry ( config/capabilities/index.yaml ), you must regenerate the Backstage catalog: 1 python3 scripts/generate_catalog.py To view the local governance docs (requires MkDocs): 1 mkdocs serve","title":"Governance &amp; Documentation"},{"location":"onboarding/#key-documentation-to-read","text":"Architecture : docs/architecture.md Backstage Integration : docs/backstage.md API Usage : docs/api_usage.md Constitution : .specify/memory/constitution.md","title":"Key Documentation to Read"},{"location":"policy_schema/","text":"Policy Schema: HR AI Platform Access Control \u00b6 The policy YAML is the authoritative statement of intended access for the HR AI Platform. It defines which principals can invoke which capabilities, under what conditions, and with what audit requirements. Design Principles \u00b6 Allow-list only : If a principal/capability pair isn't explicitly granted, access is denied. Most-specific match wins : When multiple policies could apply, the most specific (by principal ID > principal type > wildcard) takes precedence. Environment isolation : Policies are environment-scoped. A dev grant never applies in prod . Audit by default : All capability invocations are logged. The policy controls verbosity, not whether logging occurs. Policy Evaluation Semantics \u00b6 Scope Matching \u00b6 Capabilities use dot-notation namespacing: {domain}.{operation} or {domain}.{subdomain}.{operation} . Matching rules: - Exact match : workday.get_employee matches only that capability - Domain wildcard : workday.* matches all Workday capabilities. Note : Wildcards MUST end with .* . - Full wildcard : * matches everything (use with extreme caution) Principal Resolution Order \u00b6 When evaluating access, policies are checked in this order (first match wins): Policies matching the specific okta_subject Policies matching the principal's okta_group Policies matching the principal's type (HUMAN, MACHINE, AI_AGENT) No match \u2192 DENY Guardrail : If an inline principal definition includes both a specific binding (subject/group) AND a type , it will ONLY match on the specific binding. A warning will be logged at startup if such an ambiguous definition is detected. Condition Evaluation \u00b6 All specified conditions must be satisfied (AND logic). If any condition fails, the policy does not apply and evaluation continues to the next matching policy. Verification \u00b6 Before committing changes to policy-workday.yaml , you MUST run the verification suite to ensure no security regressions: 1 ./scripts/verify-policy run New capabilities or roles MUST include corresponding positive and negative test cases in tests/policy/scenarios/ . Implementation Requirements \u00b6 For detailed JSON Schema and examples, refer to the source document in src/adapters/auth/policy-schema.md .","title":"Policy Schema: HR AI Platform Access Control"},{"location":"policy_schema/#policy-schema-hr-ai-platform-access-control","text":"The policy YAML is the authoritative statement of intended access for the HR AI Platform. It defines which principals can invoke which capabilities, under what conditions, and with what audit requirements.","title":"Policy Schema: HR AI Platform Access Control"},{"location":"policy_schema/#design-principles","text":"Allow-list only : If a principal/capability pair isn't explicitly granted, access is denied. Most-specific match wins : When multiple policies could apply, the most specific (by principal ID > principal type > wildcard) takes precedence. Environment isolation : Policies are environment-scoped. A dev grant never applies in prod . Audit by default : All capability invocations are logged. The policy controls verbosity, not whether logging occurs.","title":"Design Principles"},{"location":"policy_schema/#policy-evaluation-semantics","text":"","title":"Policy Evaluation Semantics"},{"location":"policy_schema/#scope-matching","text":"Capabilities use dot-notation namespacing: {domain}.{operation} or {domain}.{subdomain}.{operation} . Matching rules: - Exact match : workday.get_employee matches only that capability - Domain wildcard : workday.* matches all Workday capabilities. Note : Wildcards MUST end with .* . - Full wildcard : * matches everything (use with extreme caution)","title":"Scope Matching"},{"location":"policy_schema/#principal-resolution-order","text":"When evaluating access, policies are checked in this order (first match wins): Policies matching the specific okta_subject Policies matching the principal's okta_group Policies matching the principal's type (HUMAN, MACHINE, AI_AGENT) No match \u2192 DENY Guardrail : If an inline principal definition includes both a specific binding (subject/group) AND a type , it will ONLY match on the specific binding. A warning will be logged at startup if such an ambiguous definition is detected.","title":"Principal Resolution Order"},{"location":"policy_schema/#condition-evaluation","text":"All specified conditions must be satisfied (AND logic). If any condition fails, the policy does not apply and evaluation continues to the next matching policy.","title":"Condition Evaluation"},{"location":"policy_schema/#verification","text":"Before committing changes to policy-workday.yaml , you MUST run the verification suite to ensure no security regressions: 1 ./scripts/verify-policy run New capabilities or roles MUST include corresponding positive and negative test cases in tests/policy/scenarios/ .","title":"Verification"},{"location":"policy_schema/#implementation-requirements","text":"For detailed JSON Schema and examples, refer to the source document in src/adapters/auth/policy-schema.md .","title":"Implementation Requirements"},{"location":"security_architecture/","text":"Security Architecture \u00b6 Defense in Depth Strategy \u00b6 Our platform implements security at three layers : Layer 1: Centralized Policy Engine & MCP Gateway \u00b6 What : YAML-based policy file defines all access grants. The MCP Gateway enforces these rules at the edge using verified JWT signatures. Why : Single source of truth for auditing and compliance, preventing bypass via unverified tokens. Example : AI agents cannot access workday.payroll.* capabilities even at the MCP level. Layer 2: Service-Level Validation \u00b6 What : Each business service validates its specific constraints Why : Context-aware checks (e.g., \"managers can only approve their direct reports\") Defense in Depth : Sensitive operations (Compensation, Time-Off Approval) perform explicit MFA verification in the service layer, providing a secondary safety net if policies are misconfigured. Layer 3: Data Filtering \u00b6 What : Response payloads are filtered based on principal type Why : Even if authorization succeeds, PII is removed for AI agents Example : AI agent sees employee name but not SSN Audit Trail \u00b6 Every action generates a log entry with: - Who performed the action (principal ID) - What capability was invoked - When it occurred (UTC timestamp) - What policy granted access - PII automatically redacted MFA Enforcement \u00b6 High-sensitivity operations require Multi-Factor Authentication: - \u2713 Viewing compensation data - \u2713 Updating personal information - \u2713 Approving manager-level actions Policy engine validates MFA claim in JWT token. Continuous Compliance \u00b6 All policy changes are verified against declarative test scenarios using the Policy Verification Framework before deployment. This ensures that broad wildcards or missing conditions are caught in CI/CD. Testing \u00b6 Run security test suite: 1 pytest tests/security/ -v View audit logs: 1 tail -f logs/audit.jsonl | jq .","title":"Security Architecture"},{"location":"security_architecture/#security-architecture","text":"","title":"Security Architecture"},{"location":"security_architecture/#defense-in-depth-strategy","text":"Our platform implements security at three layers :","title":"Defense in Depth Strategy"},{"location":"security_architecture/#layer-1-centralized-policy-engine-mcp-gateway","text":"What : YAML-based policy file defines all access grants. The MCP Gateway enforces these rules at the edge using verified JWT signatures. Why : Single source of truth for auditing and compliance, preventing bypass via unverified tokens. Example : AI agents cannot access workday.payroll.* capabilities even at the MCP level.","title":"Layer 1: Centralized Policy Engine &amp; MCP Gateway"},{"location":"security_architecture/#layer-2-service-level-validation","text":"What : Each business service validates its specific constraints Why : Context-aware checks (e.g., \"managers can only approve their direct reports\") Defense in Depth : Sensitive operations (Compensation, Time-Off Approval) perform explicit MFA verification in the service layer, providing a secondary safety net if policies are misconfigured.","title":"Layer 2: Service-Level Validation"},{"location":"security_architecture/#layer-3-data-filtering","text":"What : Response payloads are filtered based on principal type Why : Even if authorization succeeds, PII is removed for AI agents Example : AI agent sees employee name but not SSN","title":"Layer 3: Data Filtering"},{"location":"security_architecture/#audit-trail","text":"Every action generates a log entry with: - Who performed the action (principal ID) - What capability was invoked - When it occurred (UTC timestamp) - What policy granted access - PII automatically redacted","title":"Audit Trail"},{"location":"security_architecture/#mfa-enforcement","text":"High-sensitivity operations require Multi-Factor Authentication: - \u2713 Viewing compensation data - \u2713 Updating personal information - \u2713 Approving manager-level actions Policy engine validates MFA claim in JWT token.","title":"MFA Enforcement"},{"location":"security_architecture/#continuous-compliance","text":"All policy changes are verified against declarative test scenarios using the Policy Verification Framework before deployment. This ensures that broad wildcards or missing conditions are caught in CI/CD.","title":"Continuous Compliance"},{"location":"security_architecture/#testing","text":"Run security test suite: 1 pytest tests/security/ -v View audit logs: 1 tail -f logs/audit.jsonl | jq .","title":"Testing"},{"location":"test-mermaid/","text":"Mermaid Test Page \u00b6 Simple Flowchart \u00b6 graph TD A[Start] --> B{Is it working?} B -->|Yes| C[Great!] B -->|No| D[Debug] D --> A Sequence Diagram \u00b6 sequenceDiagram Alice->>John: Hello John, how are you? John-->>Alice: Great! Alice-)John: See you later! C4 Context Diagram (Original) \u00b6 C4Context title System Context diagram for Capability API Person(agent, \"AI Agent\", \"Automated reasoning engine requesting HR actions\") Person(admin, \"HR Admin\", \"Human user managing policies and workflows\") System(capapi, \"Capability API\", \"Governed surface exposing deterministic actions and flows\") System(backstage, \"Backstage\", \"Governance lens and catalog\") System_Ext(workday, \"Workday\", \"Core HRIS containing employee and payroll records\") System_Ext(okta, \"Okta\", \"Identity Provider for OIDC authentication\") Rel(agent, capapi, \"Invokes Actions/Flows\", \"HTTPS/JSON + JWT\") Rel(admin, capapi, \"Manages Policies\", \"YAML/CLI\") Rel(admin, backstage, \"Inspects Governance\", \"HTTPS/Web\") Rel(capapi, workday, \"Reads/Writes Employee Data\", \"REST API/OAuth2\") Rel(capapi, okta, \"Validates Tokens\", \"JWKS endpoint\") UpdateRelStyle(agent, capapi, $textColor=\"blue\", $lineColor=\"blue\")","title":"Mermaid Test"},{"location":"test-mermaid/#mermaid-test-page","text":"","title":"Mermaid Test Page"},{"location":"test-mermaid/#simple-flowchart","text":"graph TD A[Start] --> B{Is it working?} B -->|Yes| C[Great!] B -->|No| D[Debug] D --> A","title":"Simple Flowchart"},{"location":"test-mermaid/#sequence-diagram","text":"sequenceDiagram Alice->>John: Hello John, how are you? John-->>Alice: Great! Alice-)John: See you later!","title":"Sequence Diagram"},{"location":"test-mermaid/#c4-context-diagram-original","text":"C4Context title System Context diagram for Capability API Person(agent, \"AI Agent\", \"Automated reasoning engine requesting HR actions\") Person(admin, \"HR Admin\", \"Human user managing policies and workflows\") System(capapi, \"Capability API\", \"Governed surface exposing deterministic actions and flows\") System(backstage, \"Backstage\", \"Governance lens and catalog\") System_Ext(workday, \"Workday\", \"Core HRIS containing employee and payroll records\") System_Ext(okta, \"Okta\", \"Identity Provider for OIDC authentication\") Rel(agent, capapi, \"Invokes Actions/Flows\", \"HTTPS/JSON + JWT\") Rel(admin, capapi, \"Manages Policies\", \"YAML/CLI\") Rel(admin, backstage, \"Inspects Governance\", \"HTTPS/Web\") Rel(capapi, workday, \"Reads/Writes Employee Data\", \"REST API/OAuth2\") Rel(capapi, okta, \"Validates Tokens\", \"JWKS endpoint\") UpdateRelStyle(agent, capapi, $textColor=\"blue\", $lineColor=\"blue\")","title":"C4 Context Diagram (Original)"},{"location":"troubleshooting/","text":"Troubleshooting Guide \u00b6 Common issues encountered when working with the Capability API. Authentication & Authorization \u00b6 1. Token Expired ( token_expired ) \u00b6 Cause : The mock JWT token has reached its exp time. Solution : Issue a new token using the MockOktaProvider.issue_token() method in your test or script. AI Agents have a default TTL of 300 seconds. 2. Access Denied ( FORBIDDEN ) \u00b6 Cause : The principal does not have the required capability in the current environment. Solution : - Check config/policy-workday.yaml to ensure the principal/group is mapped to the capability. - Verify that MFA is present in the token if the policy requires it ( amr: [\"mfa\"] ). - Ensure the ENVIRONMENT env var matches the policy environment. 3. Ambiguous Principal Warning \u00b6 Symptom : Startup log shows WARNING: Policy '...' has inline principal with both type '...' and a specific binding. Cause : A policy rule defines an inline principal that includes both a generic type (e.g., AI_AGENT ) and a specific okta_subject or okta_group . Impact : The policy will ONLY match the specific binding. It will NOT act as a generic grant for all principals of that type. Solution : Decide if the policy is meant for one specific entity (remove type ) or all entities of a type (remove okta_subject / okta_group ). 4. Invalid or missing X-Test-Secret \u00b6 Symptom : 403 Forbidden when calling /auth/test/tokens or /auth/test/users . Cause : The X-Test-Secret header is missing or does not match the MOCK_OKTA_TEST_SECRET configuration. Solution : Add -H \"X-Test-Secret: mock-okta-secret\" to your curl command, or check your .env file for the correct secret. 5. MCP Unauthorized: Invalid or malformed token \u00b6 Symptom : MCP tools return ERROR: UNAUTHORIZED: Invalid or malformed token . Cause : The MCP server now enforces full signature verification. Forged tokens (e.g., those signed with HS256 and a static secret) are now rejected. Solution : Ensure your client is sending a valid token issued by the MockOktaProvider (local) or real Okta (prod). Connector Issues \u00b6 1. Employee Not Found ( EMPLOYEE_NOT_FOUND ) \u00b6 Cause : The requested employee ID does not exist in the YAML fixtures. Solution : Verify the ID in src/adapters/workday/fixtures/employees.yaml . Use /actions/test/reload-fixtures if you just added it. 2. Connector Timeout ( CONNECTOR_TIMEOUT ) \u00b6 Cause : Failure injection is enabled or the base latency is set too high. Solution : Check WorkdaySimulationConfig in your dependency injection or environment variables. Development Tools \u00b6 1. Pydantic Metadata Errors \u00b6 Cause : A new model field was added without a Field(description=\"...\") . Solution : Run pytest tests/unit/test_documentation_metadata.py to identify missing descriptions and add them. 2. Spec/Task Desync \u00b6 Cause : The code has diverged from the tasks.md or spec.md . Solution : Re-run /speckit.analyze to detect inconsistencies and update documentation accordingly.","title":"Troubleshooting Guide"},{"location":"troubleshooting/#troubleshooting-guide","text":"Common issues encountered when working with the Capability API.","title":"Troubleshooting Guide"},{"location":"troubleshooting/#authentication-authorization","text":"","title":"Authentication &amp; Authorization"},{"location":"troubleshooting/#1-token-expired-token_expired","text":"Cause : The mock JWT token has reached its exp time. Solution : Issue a new token using the MockOktaProvider.issue_token() method in your test or script. AI Agents have a default TTL of 300 seconds.","title":"1. Token Expired (token_expired)"},{"location":"troubleshooting/#2-access-denied-forbidden","text":"Cause : The principal does not have the required capability in the current environment. Solution : - Check config/policy-workday.yaml to ensure the principal/group is mapped to the capability. - Verify that MFA is present in the token if the policy requires it ( amr: [\"mfa\"] ). - Ensure the ENVIRONMENT env var matches the policy environment.","title":"2. Access Denied (FORBIDDEN)"},{"location":"troubleshooting/#3-ambiguous-principal-warning","text":"Symptom : Startup log shows WARNING: Policy '...' has inline principal with both type '...' and a specific binding. Cause : A policy rule defines an inline principal that includes both a generic type (e.g., AI_AGENT ) and a specific okta_subject or okta_group . Impact : The policy will ONLY match the specific binding. It will NOT act as a generic grant for all principals of that type. Solution : Decide if the policy is meant for one specific entity (remove type ) or all entities of a type (remove okta_subject / okta_group ).","title":"3. Ambiguous Principal Warning"},{"location":"troubleshooting/#4-invalid-or-missing-x-test-secret","text":"Symptom : 403 Forbidden when calling /auth/test/tokens or /auth/test/users . Cause : The X-Test-Secret header is missing or does not match the MOCK_OKTA_TEST_SECRET configuration. Solution : Add -H \"X-Test-Secret: mock-okta-secret\" to your curl command, or check your .env file for the correct secret.","title":"4. Invalid or missing X-Test-Secret"},{"location":"troubleshooting/#5-mcp-unauthorized-invalid-or-malformed-token","text":"Symptom : MCP tools return ERROR: UNAUTHORIZED: Invalid or malformed token . Cause : The MCP server now enforces full signature verification. Forged tokens (e.g., those signed with HS256 and a static secret) are now rejected. Solution : Ensure your client is sending a valid token issued by the MockOktaProvider (local) or real Okta (prod).","title":"5. MCP Unauthorized: Invalid or malformed token"},{"location":"troubleshooting/#connector-issues","text":"","title":"Connector Issues"},{"location":"troubleshooting/#1-employee-not-found-employee_not_found","text":"Cause : The requested employee ID does not exist in the YAML fixtures. Solution : Verify the ID in src/adapters/workday/fixtures/employees.yaml . Use /actions/test/reload-fixtures if you just added it.","title":"1. Employee Not Found (EMPLOYEE_NOT_FOUND)"},{"location":"troubleshooting/#2-connector-timeout-connector_timeout","text":"Cause : Failure injection is enabled or the base latency is set too high. Solution : Check WorkdaySimulationConfig in your dependency injection or environment variables.","title":"2. Connector Timeout (CONNECTOR_TIMEOUT)"},{"location":"troubleshooting/#development-tools","text":"","title":"Development Tools"},{"location":"troubleshooting/#1-pydantic-metadata-errors","text":"Cause : A new model field was added without a Field(description=\"...\") . Solution : Run pytest tests/unit/test_documentation_metadata.py to identify missing descriptions and add them.","title":"1. Pydantic Metadata Errors"},{"location":"troubleshooting/#2-spectask-desync","text":"Cause : The code has diverged from the tasks.md or spec.md . Solution : Re-run /speckit.analyze to detect inconsistencies and update documentation accordingly.","title":"2. Spec/Task Desync"},{"location":"modules/api_layer/","text":"API Layer \u00b6 The API layer is the public surface of the HR AI Platform. It is designed to be consumed by diverse clients including AI agents, web applications, and automated workflows. Design Philosophy \u00b6 Uniformity : Whether an operation is read-only (query) or state-mutating (action), it follows the same request/response pattern. Governance : No action can be executed without a valid OIDC token and a matching entry in the policy.yaml . Auditability : Every response contains a meta.provenance block identifying who did what and when. Core Components \u00b6 1. Routes ( /routes ) \u00b6 Actions : Atomic, synchronous HR operations (e.g., get_employee , request_time_off ). Flows : Triggers for multi-step HR processes (e.g., onboarding ). 2. Dependencies ( dependencies.py ) \u00b6 Centralized logic for: - Authentication (OIDC/JWT validation) - Authorization (Policy Engine injection) - Infrastructure Ports (Connectors, Flow Runners) Execution Flow \u00b6 Request : Client sends POST to /actions/{domain}/{action} . Auth : get_current_principal validates the JWT and extracts VerifiedPrincipal (preserving raw claims for scope validation). Authorization : ActionService asks PolicyEngine if the principal is allowed to invoke the capability. Execution : ActionService calls the appropriate adapter (e.g., WorkdaySimulator ). Response : Result is wrapped in ActionResponse with execution metadata. Key Exports \u00b6 app : The main FastAPI application instance. get_current_principal : Dependency for extracting OIDC identity from headers. get_policy_engine : Dependency providing access to the centralized policy evaluator. get_connector : Dependency providing access to the Workday Simulator or external ports. Architectural Constraints \u00b6 Identity First : Every route MUST use Depends(get_current_principal) unless explicitly public (e.g., /health ). Policy Governed : Business logic MUST NOT perform raw auth checks; use PolicyEngine via ActionService . Response Envelopes : All actions MUST return ActionResponse to ensure consistent audit trails (provenance).","title":"API Layer"},{"location":"modules/api_layer/#api-layer","text":"The API layer is the public surface of the HR AI Platform. It is designed to be consumed by diverse clients including AI agents, web applications, and automated workflows.","title":"API Layer"},{"location":"modules/api_layer/#design-philosophy","text":"Uniformity : Whether an operation is read-only (query) or state-mutating (action), it follows the same request/response pattern. Governance : No action can be executed without a valid OIDC token and a matching entry in the policy.yaml . Auditability : Every response contains a meta.provenance block identifying who did what and when.","title":"Design Philosophy"},{"location":"modules/api_layer/#core-components","text":"","title":"Core Components"},{"location":"modules/api_layer/#1-routes-routes","text":"Actions : Atomic, synchronous HR operations (e.g., get_employee , request_time_off ). Flows : Triggers for multi-step HR processes (e.g., onboarding ).","title":"1. Routes (/routes)"},{"location":"modules/api_layer/#2-dependencies-dependenciespy","text":"Centralized logic for: - Authentication (OIDC/JWT validation) - Authorization (Policy Engine injection) - Infrastructure Ports (Connectors, Flow Runners)","title":"2. Dependencies (dependencies.py)"},{"location":"modules/api_layer/#execution-flow","text":"Request : Client sends POST to /actions/{domain}/{action} . Auth : get_current_principal validates the JWT and extracts VerifiedPrincipal (preserving raw claims for scope validation). Authorization : ActionService asks PolicyEngine if the principal is allowed to invoke the capability. Execution : ActionService calls the appropriate adapter (e.g., WorkdaySimulator ). Response : Result is wrapped in ActionResponse with execution metadata.","title":"Execution Flow"},{"location":"modules/api_layer/#key-exports","text":"app : The main FastAPI application instance. get_current_principal : Dependency for extracting OIDC identity from headers. get_policy_engine : Dependency providing access to the centralized policy evaluator. get_connector : Dependency providing access to the Workday Simulator or external ports.","title":"Key Exports"},{"location":"modules/api_layer/#architectural-constraints","text":"Identity First : Every route MUST use Depends(get_current_principal) unless explicitly public (e.g., /health ). Policy Governed : Business logic MUST NOT perform raw auth checks; use PolicyEngine via ActionService . Response Envelopes : All actions MUST return ActionResponse to ensure consistent audit trails (provenance).","title":"Architectural Constraints"},{"location":"modules/auth_adapter/","text":"Auth Adapter \u00b6 Identity verification and token management for the Capability API. This module provides a mock OIDC provider for local development and a verifier for JWT tokens. Key Components \u00b6 MockOktaProvider : Issues cryptographically valid RSA-signed JWTs. MockTokenVerifier : Validates tokens against the mock provider. VerifiedPrincipal : Domain object representing an authenticated identity. Dependencies \u00b6 Internal : src.adapters.auth.mock_okta , src.adapters.auth.verifier . External : PyJWT , cryptography . Architectural Constraints \u00b6 MUST NOT store real credentials. Issued tokens SHOULD match the structure of real Okta OIDC tokens. Verifier MUST extract principal_type and groups for policy evaluation. Test endpoints ( /test/tokens , /test/users ) MUST require the X-Test-Secret header, configured via MOCK_OKTA_TEST_SECRET . Policy Schema \u00b6 For detailed information on how policies are structured and validated, see Policy Schema .","title":"Auth Adapter"},{"location":"modules/auth_adapter/#auth-adapter","text":"Identity verification and token management for the Capability API. This module provides a mock OIDC provider for local development and a verifier for JWT tokens.","title":"Auth Adapter"},{"location":"modules/auth_adapter/#key-components","text":"MockOktaProvider : Issues cryptographically valid RSA-signed JWTs. MockTokenVerifier : Validates tokens against the mock provider. VerifiedPrincipal : Domain object representing an authenticated identity.","title":"Key Components"},{"location":"modules/auth_adapter/#dependencies","text":"Internal : src.adapters.auth.mock_okta , src.adapters.auth.verifier . External : PyJWT , cryptography .","title":"Dependencies"},{"location":"modules/auth_adapter/#architectural-constraints","text":"MUST NOT store real credentials. Issued tokens SHOULD match the structure of real Okta OIDC tokens. Verifier MUST extract principal_type and groups for policy evaluation. Test endpoints ( /test/tokens , /test/users ) MUST require the X-Test-Secret header, configured via MOCK_OKTA_TEST_SECRET .","title":"Architectural Constraints"},{"location":"modules/auth_adapter/#policy-schema","text":"For detailed information on how policies are structured and validated, see Policy Schema .","title":"Policy Schema"},{"location":"modules/domain_entities/","text":"Domain Entities \u00b6 Defines the core data structures for the Capability API. These models are shared across the domain core and adapters. Core Models \u00b6 Action Protocol \u00b6 ActionRequest : Standard envelope for all action inputs. parameters : Dict of arguments specific to the action. dry_run : Boolean to simulate execution without side effects. ActionResponse : Standard envelope for all action outputs. data : The actual result payload (Dict or List). meta : Metadata wrapper containing provenance . Provenance : Audit trail metadata. source : Originating adapter/system. timestamp : Execution time (UTC). trace_id : Unique correlation ID. latency_ms : Execution duration. actor : Principal ID who invoked the action. Shared Types \u00b6 Money : {amount, currency, frequency} EmployeeReference : {employee_id, display_name} Architectural Constraints \u00b6 The domain/ directory MUST NOT import from adapters/ or api/ . All entities MUST be Pydantic models with clear descriptions for documentation generation.","title":"Domain Entities"},{"location":"modules/domain_entities/#domain-entities","text":"Defines the core data structures for the Capability API. These models are shared across the domain core and adapters.","title":"Domain Entities"},{"location":"modules/domain_entities/#core-models","text":"","title":"Core Models"},{"location":"modules/domain_entities/#action-protocol","text":"ActionRequest : Standard envelope for all action inputs. parameters : Dict of arguments specific to the action. dry_run : Boolean to simulate execution without side effects. ActionResponse : Standard envelope for all action outputs. data : The actual result payload (Dict or List). meta : Metadata wrapper containing provenance . Provenance : Audit trail metadata. source : Originating adapter/system. timestamp : Execution time (UTC). trace_id : Unique correlation ID. latency_ms : Execution duration. actor : Principal ID who invoked the action.","title":"Action Protocol"},{"location":"modules/domain_entities/#shared-types","text":"Money : {amount, currency, frequency} EmployeeReference : {employee_id, display_name}","title":"Shared Types"},{"location":"modules/domain_entities/#architectural-constraints","text":"The domain/ directory MUST NOT import from adapters/ or api/ . All entities MUST be Pydantic models with clear descriptions for documentation generation.","title":"Architectural Constraints"},{"location":"modules/filesystem_adapter/","text":"Filesystem Adapters \u00b6 Implementation of ports that interact with the local disk. These adapters provide persistence and execution capabilities using the local filesystem. Key Components \u00b6 FilePolicyLoaderAdapter : Loads YAML policies from disk. LocalFlowRunnerAdapter : Simulates flow execution using local state. Implementation Details \u00b6 Ports : Implements PolicyLoaderPort and FlowRunnerPort . Dependencies : src.domain.entities.* , src.domain.ports.* . Constraints \u00b6 MUST NOT contain business logic. Path handling MUST be cross-platform compatible.","title":"Filesystem Adapters"},{"location":"modules/filesystem_adapter/#filesystem-adapters","text":"Implementation of ports that interact with the local disk. These adapters provide persistence and execution capabilities using the local filesystem.","title":"Filesystem Adapters"},{"location":"modules/filesystem_adapter/#key-components","text":"FilePolicyLoaderAdapter : Loads YAML policies from disk. LocalFlowRunnerAdapter : Simulates flow execution using local state.","title":"Key Components"},{"location":"modules/filesystem_adapter/#implementation-details","text":"Ports : Implements PolicyLoaderPort and FlowRunnerPort . Dependencies : src.domain.entities.* , src.domain.ports.* .","title":"Implementation Details"},{"location":"modules/filesystem_adapter/#constraints","text":"MUST NOT contain business logic. Path handling MUST be cross-platform compatible.","title":"Constraints"},{"location":"modules/policy_verification/","text":"Policy Verification Module \u00b6 Overview \u00b6 The Policy Verification module ensures that the Capability API's security posture remains intact across policy updates. it uses declarative YAML scenarios to simulate access requests and verify the Policy Engine's behavior. Key Features \u00b6 Declarative Testing : Security requirements defined as human-readable YAML. CI/CD Integration : Automatically blocks PRs that introduce over-permissive or broken policies. Stakeholder Reporting : Generates Markdown, HTML, and JUnit reports for compliance auditing. Backstage TechDocs : Automated publishing of the verification dashboard to Backstage. Important Links \u00b6 Technical README : See src/domain/services/README.ai.md for implementation details and CLI usage. Test Scenarios : See tests/policy/scenarios/ directory for baseline and regression test definitions. Governance Dashboard : Governance framework overview. Usage \u00b6 To verify the current policy configuration and generate a Markdown report for TechDocs: 1 ./scripts/verify-policy run --format table The report is saved to docs/policy-verification/latest.md .","title":"Policy Verification Module"},{"location":"modules/policy_verification/#policy-verification-module","text":"","title":"Policy Verification Module"},{"location":"modules/policy_verification/#overview","text":"The Policy Verification module ensures that the Capability API's security posture remains intact across policy updates. it uses declarative YAML scenarios to simulate access requests and verify the Policy Engine's behavior.","title":"Overview"},{"location":"modules/policy_verification/#key-features","text":"Declarative Testing : Security requirements defined as human-readable YAML. CI/CD Integration : Automatically blocks PRs that introduce over-permissive or broken policies. Stakeholder Reporting : Generates Markdown, HTML, and JUnit reports for compliance auditing. Backstage TechDocs : Automated publishing of the verification dashboard to Backstage.","title":"Key Features"},{"location":"modules/policy_verification/#important-links","text":"Technical README : See src/domain/services/README.ai.md for implementation details and CLI usage. Test Scenarios : See tests/policy/scenarios/ directory for baseline and regression test definitions. Governance Dashboard : Governance framework overview.","title":"Important Links"},{"location":"modules/policy_verification/#usage","text":"To verify the current policy configuration and generate a Markdown report for TechDocs: 1 ./scripts/verify-policy run --format table The report is saved to docs/policy-verification/latest.md .","title":"Usage"},{"location":"modules/token_exchange/","text":"OAuth 2.0 Token Exchange & Scoping \u00b6 This module implements RFC 8693 Token Exchange to improve security by reducing the \"blast radius\" of tokens used by the MCP Server. Overview \u00b6 The MCP Server acts as an intermediary between the User (via Chainlit/UI) and the Capability API. Instead of holding the user's long-lived (1 hour) full-access token, the MCP Server exchanges it for a short-lived (5 minute) scoped token ( mcp:use ). Security Benefits \u00b6 Blast Radius Reduction : MCP-held tokens expire in 5 minutes. Scope Isolation : Tokens with mcp:use scope cannot be used to call the Capability API directly (unless acting_as claim is present and validated, effectively binding it to the MCP server context). Provenance : Audit logs show acting_through: mcp-server and link back to the original user token via original_token_id . Freshness : Sensitive actions (e.g., payroll) enforce max_auth_age_seconds (Step-Up Auth). Architecture \u00b6 Token Flow \u00b6 sequenceDiagram User->>UI: Login UI->>Okta: Authenticate Okta->>UI: User Token (1h) UI->>MCP: User Token MCP->>Okta: Exchange(User Token, scope=mcp:use) Okta->>MCP: MCP Token (5m) MCP->>API: Execute Action (MCP Token) API->>Policy: Evaluate(scope=mcp:use) Policy->>API: Allow API->>MCP: Result Policy Configuration \u00b6 New conditions available in policy-*.yaml : 1 2 3 conditions : required_scope : \"mcp:use\" # Enforce specific scope max_auth_age_seconds : 300 # Enforce recent authentication Testing \u00b6 Run the demo script: 1 ./scripts/demo/token_exchange_demo.sh","title":"OAuth 2.0 Token Exchange &amp; Scoping"},{"location":"modules/token_exchange/#oauth-20-token-exchange-scoping","text":"This module implements RFC 8693 Token Exchange to improve security by reducing the \"blast radius\" of tokens used by the MCP Server.","title":"OAuth 2.0 Token Exchange &amp; Scoping"},{"location":"modules/token_exchange/#overview","text":"The MCP Server acts as an intermediary between the User (via Chainlit/UI) and the Capability API. Instead of holding the user's long-lived (1 hour) full-access token, the MCP Server exchanges it for a short-lived (5 minute) scoped token ( mcp:use ).","title":"Overview"},{"location":"modules/token_exchange/#security-benefits","text":"Blast Radius Reduction : MCP-held tokens expire in 5 minutes. Scope Isolation : Tokens with mcp:use scope cannot be used to call the Capability API directly (unless acting_as claim is present and validated, effectively binding it to the MCP server context). Provenance : Audit logs show acting_through: mcp-server and link back to the original user token via original_token_id . Freshness : Sensitive actions (e.g., payroll) enforce max_auth_age_seconds (Step-Up Auth).","title":"Security Benefits"},{"location":"modules/token_exchange/#architecture","text":"","title":"Architecture"},{"location":"modules/token_exchange/#token-flow","text":"sequenceDiagram User->>UI: Login UI->>Okta: Authenticate Okta->>UI: User Token (1h) UI->>MCP: User Token MCP->>Okta: Exchange(User Token, scope=mcp:use) Okta->>MCP: MCP Token (5m) MCP->>API: Execute Action (MCP Token) API->>Policy: Evaluate(scope=mcp:use) Policy->>API: Allow API->>MCP: Result","title":"Token Flow"},{"location":"modules/token_exchange/#policy-configuration","text":"New conditions available in policy-*.yaml : 1 2 3 conditions : required_scope : \"mcp:use\" # Enforce specific scope max_auth_age_seconds : 300 # Enforce recent authentication","title":"Policy Configuration"},{"location":"modules/token_exchange/#testing","text":"Run the demo script: 1 ./scripts/demo/token_exchange_demo.sh","title":"Testing"},{"location":"modules/workday_adapter/","text":"Workday Simulator Adapter \u00b6 Provides a simulation of the Workday HRIS system for local development and testing. Exposes synchronous \"Actions\" for HCM, Time Tracking, and Payroll domains. Overview \u00b6 The Workday Simulator is a critical component for development, allowing for safe, fast, and deterministic testing of HR capabilities. Functional Documentation : Purpose, domains, and personas. Technical Documentation : Architecture, state management, and simulation features. Capabilities \u00b6 HCM Domain ( workday.hcm ) \u00b6 get_employee(employee_id) : Retrieve employee details. get_manager_chain(employee_id) : Retrieve management hierarchy. list_direct_reports(manager_id) : List employees reporting to a manager. update_contact_info(employee_id, updates) : Update email/phone. Time Domain ( workday.time ) \u00b6 get_balance(employee_id) : Check PTO/Sick balances. request(employee_id, type, dates) : Submit time-off request. cancel(request_id, reason) : Cancel a pending/approved request. approve(request_id, approver_id) : Approve a request (Manager only). Payroll Domain ( workday.payroll ) \u00b6 get_compensation(employee_id) : View salary/bonus (High sensitivity, MFA required). Schemas \u00b6 See src/domain/entities/action.py for full Pydantic models.","title":"Workday Simulator Adapter"},{"location":"modules/workday_adapter/#workday-simulator-adapter","text":"Provides a simulation of the Workday HRIS system for local development and testing. Exposes synchronous \"Actions\" for HCM, Time Tracking, and Payroll domains.","title":"Workday Simulator Adapter"},{"location":"modules/workday_adapter/#overview","text":"The Workday Simulator is a critical component for development, allowing for safe, fast, and deterministic testing of HR capabilities. Functional Documentation : Purpose, domains, and personas. Technical Documentation : Architecture, state management, and simulation features.","title":"Overview"},{"location":"modules/workday_adapter/#capabilities","text":"","title":"Capabilities"},{"location":"modules/workday_adapter/#hcm-domain-workdayhcm","text":"get_employee(employee_id) : Retrieve employee details. get_manager_chain(employee_id) : Retrieve management hierarchy. list_direct_reports(manager_id) : List employees reporting to a manager. update_contact_info(employee_id, updates) : Update email/phone.","title":"HCM Domain (workday.hcm)"},{"location":"modules/workday_adapter/#time-domain-workdaytime","text":"get_balance(employee_id) : Check PTO/Sick balances. request(employee_id, type, dates) : Submit time-off request. cancel(request_id, reason) : Cancel a pending/approved request. approve(request_id, approver_id) : Approve a request (Manager only).","title":"Time Domain (workday.time)"},{"location":"modules/workday_adapter/#payroll-domain-workdaypayroll","text":"get_compensation(employee_id) : View salary/bonus (High sensitivity, MFA required).","title":"Payroll Domain (workday.payroll)"},{"location":"modules/workday_adapter/#schemas","text":"See src/domain/entities/action.py for full Pydantic models.","title":"Schemas"},{"location":"modules/workday_functional/","text":"Functional Documentation: Workday Simulator \u00b6 The Workday Simulator provides a realistic, safe environment for developing and testing HR AI capabilities without exposing sensitive real-world data or requiring a live Workday connection. Why we use a Simulator \u00b6 Safety : We can test automated terminations or compensation changes without risk to real employees. Auth Testing : It allows us to \"stress test\" our security policies by simulating different roles (Manager vs. Employee). Speed : No network latency to external Workday servers during development. Edge Cases : We can easily create \"unhappy\" paths, like insufficient leave balances, to see how the AI handles errors. Supported HR Domains \u00b6 1. HCM (Human Capital Management) \u00b6 Simulates core employee record management: * Employee Directory : Looking up basic profile info. * Org Structure : Visualizing reporting lines and department hierarchies. * Manager Chains : Understanding the path from an individual contributor up to the CEO. * Lifecycle : Updating profile details and triggering termination workflows. 2. Time Tracking \u00b6 Simulates leave management workflows: * Balances : Real-time tracking of PTO and Sick Leave. * Requests : Submitting new time-off requests. * Approvals : The multi-step flow where a manager reviews and approves a request, automatically updating the employee's balance. 3. Payroll \u00b6 Simulates sensitive compensation data: * Salary Info : Viewing base salary, bonuses, and equity grants. * Pay Statements : Generating detailed pay slips with tax breakdowns and net pay. Test Personas \u00b6 We provide a set of pre-configured identities in our \"fixtures\" to test various scenarios: ID Name Role Purpose EMP001 Alice Johnson Senior Engineer The primary test user for self-service actions. EMP042 Bob Martinez Engineering Manager Used to test manager approvals and team visibility. EMP100 Carol Chen VP Engineering Used to test deep manager chains and org charts. EMP200 Diana Ross CEO The root of the organization. How to perform a \"Reset\" \u00b6 If you have modified data during a demo or test session and want to return to the original \"Golden State,\" you can trigger a full service reload (clearing all caches and re-reading files) by calling: POST /demo/reset (Note: Requires ENABLE_DEMO_RESET=true environment variable).","title":"Functional Documentation: Workday Simulator"},{"location":"modules/workday_functional/#functional-documentation-workday-simulator","text":"The Workday Simulator provides a realistic, safe environment for developing and testing HR AI capabilities without exposing sensitive real-world data or requiring a live Workday connection.","title":"Functional Documentation: Workday Simulator"},{"location":"modules/workday_functional/#why-we-use-a-simulator","text":"Safety : We can test automated terminations or compensation changes without risk to real employees. Auth Testing : It allows us to \"stress test\" our security policies by simulating different roles (Manager vs. Employee). Speed : No network latency to external Workday servers during development. Edge Cases : We can easily create \"unhappy\" paths, like insufficient leave balances, to see how the AI handles errors.","title":"Why we use a Simulator"},{"location":"modules/workday_functional/#supported-hr-domains","text":"","title":"Supported HR Domains"},{"location":"modules/workday_functional/#1-hcm-human-capital-management","text":"Simulates core employee record management: * Employee Directory : Looking up basic profile info. * Org Structure : Visualizing reporting lines and department hierarchies. * Manager Chains : Understanding the path from an individual contributor up to the CEO. * Lifecycle : Updating profile details and triggering termination workflows.","title":"1. HCM (Human Capital Management)"},{"location":"modules/workday_functional/#2-time-tracking","text":"Simulates leave management workflows: * Balances : Real-time tracking of PTO and Sick Leave. * Requests : Submitting new time-off requests. * Approvals : The multi-step flow where a manager reviews and approves a request, automatically updating the employee's balance.","title":"2. Time Tracking"},{"location":"modules/workday_functional/#3-payroll","text":"Simulates sensitive compensation data: * Salary Info : Viewing base salary, bonuses, and equity grants. * Pay Statements : Generating detailed pay slips with tax breakdowns and net pay.","title":"3. Payroll"},{"location":"modules/workday_functional/#test-personas","text":"We provide a set of pre-configured identities in our \"fixtures\" to test various scenarios: ID Name Role Purpose EMP001 Alice Johnson Senior Engineer The primary test user for self-service actions. EMP042 Bob Martinez Engineering Manager Used to test manager approvals and team visibility. EMP100 Carol Chen VP Engineering Used to test deep manager chains and org charts. EMP200 Diana Ross CEO The root of the organization.","title":"Test Personas"},{"location":"modules/workday_functional/#how-to-perform-a-reset","text":"If you have modified data during a demo or test session and want to return to the original \"Golden State,\" you can trigger a full service reload (clearing all caches and re-reading files) by calling: POST /demo/reset (Note: Requires ENABLE_DEMO_RESET=true environment variable).","title":"How to perform a \"Reset\""},{"location":"modules/workday_technical/","text":"Technical Documentation: Workday Simulator \u00b6 This document provides a deep dive into the implementation of the Workday Simulator adapter. Architecture \u00b6 The simulator is implemented as a Hexagonal Adapter that fulfills the ConnectorPort interface. It is designed to be a \"plug-and-play\" replacement for a real Workday integration. Core Components \u00b6 WorkdaySimulator (client.py) : The main entry point. It handles action dispatching, latency simulation, and failure injection. FixtureLoader (loader.py) : Responsible for reading YAML files and instantiating Pydantic models. It performs a two-pass resolution to link manager references correctly. Domain Services (services/) : * WorkdayHCMService : Logic for employee data and organization structure. * WorkdayTimeService : Logic for leave balances and request lifecycles. * WorkdayPayrollService : Logic for compensation and pay statements. In-Memory State \u00b6 Unlike a stateless proxy, this simulator maintains a mutable in-memory state . - Changes made via update_employee or request_time_off are stored in the current process memory. - Persistence : State is volatile and resets when the server restarts. - Reloading : The /demo/reset endpoint allows clearing all service caches and refreshing state from the YAML files without a restart. Simulation Features \u00b6 1. Latency Injection \u00b6 The simulator calculates a delay for every operation based on the WorkdaySimulationConfig : - Base Latency : 50ms (default). - Variance : \u00b1 50ms. - Write Multiplier : Operations that modify state (e.g., approve , terminate ) are multiplied by 3.0 to simulate slower write-consistency in distributed systems. 2. Failure Injection \u00b6 To test system resilience, the simulator supports configurable failure rates: - failure_rate : Probability (0.0 - 1.0) of returning a CONNECTOR_UNAVAILABLE (503) error. - timeout_rate : Probability of raising a CONNECTOR_TIMEOUT (504) error. Adding New Operations \u00b6 Define Model : Add the Pydantic schema to src/adapters/workday/domain/ . Update Fixture : Add sample data to the relevant YAML in src/adapters/workday/fixtures/ . Implement Logic : Add a method to the appropriate service class in services/ . Register Action : The WorkdaySimulator.execute method uses getattr to automatically find methods in its service sub-classes. Ensure the method name matches the suffix of the capability string (e.g., get_employee ).","title":"Technical Documentation: Workday Simulator"},{"location":"modules/workday_technical/#technical-documentation-workday-simulator","text":"This document provides a deep dive into the implementation of the Workday Simulator adapter.","title":"Technical Documentation: Workday Simulator"},{"location":"modules/workday_technical/#architecture","text":"The simulator is implemented as a Hexagonal Adapter that fulfills the ConnectorPort interface. It is designed to be a \"plug-and-play\" replacement for a real Workday integration.","title":"Architecture"},{"location":"modules/workday_technical/#core-components","text":"WorkdaySimulator (client.py) : The main entry point. It handles action dispatching, latency simulation, and failure injection. FixtureLoader (loader.py) : Responsible for reading YAML files and instantiating Pydantic models. It performs a two-pass resolution to link manager references correctly. Domain Services (services/) : * WorkdayHCMService : Logic for employee data and organization structure. * WorkdayTimeService : Logic for leave balances and request lifecycles. * WorkdayPayrollService : Logic for compensation and pay statements.","title":"Core Components"},{"location":"modules/workday_technical/#in-memory-state","text":"Unlike a stateless proxy, this simulator maintains a mutable in-memory state . - Changes made via update_employee or request_time_off are stored in the current process memory. - Persistence : State is volatile and resets when the server restarts. - Reloading : The /demo/reset endpoint allows clearing all service caches and refreshing state from the YAML files without a restart.","title":"In-Memory State"},{"location":"modules/workday_technical/#simulation-features","text":"","title":"Simulation Features"},{"location":"modules/workday_technical/#1-latency-injection","text":"The simulator calculates a delay for every operation based on the WorkdaySimulationConfig : - Base Latency : 50ms (default). - Variance : \u00b1 50ms. - Write Multiplier : Operations that modify state (e.g., approve , terminate ) are multiplied by 3.0 to simulate slower write-consistency in distributed systems.","title":"1. Latency Injection"},{"location":"modules/workday_technical/#2-failure-injection","text":"To test system resilience, the simulator supports configurable failure rates: - failure_rate : Probability (0.0 - 1.0) of returning a CONNECTOR_UNAVAILABLE (503) error. - timeout_rate : Probability of raising a CONNECTOR_TIMEOUT (504) error.","title":"2. Failure Injection"},{"location":"modules/workday_technical/#adding-new-operations","text":"Define Model : Add the Pydantic schema to src/adapters/workday/domain/ . Update Fixture : Add sample data to the relevant YAML in src/adapters/workday/fixtures/ . Implement Logic : Add a method to the appropriate service class in services/ . Register Action : The WorkdaySimulator.execute method uses getattr to automatically find methods in its service sub-classes. Ensure the method name matches the suffix of the capability string (e.g., get_employee ).","title":"Adding New Operations"},{"location":"policy-verification/latest/","text":"Policy Verification Report \u00b6 Timestamp : 2026-02-02 21:32:34 Policy Version : unknown Status : \ud83d\udfe2 PASS Summary \u00b6 Metric Value Total Tests 10 Passed 10 Failed 0 Pass Rate 100.0% Full Results \u00b6 ID Scenario Outcome Policy Duration ADM-001 Admin full access with MFA \u2705 admin-full-access 0.05ms ADM-002 Admin denied WITHOUT MFA \u2705 None 0.05ms EMP-001 Employee can read directory \u2705 employee-self-service-read 0.03ms EMP-002 Employee can manage own time off \u2705 employee-time-self-service 0.02ms EMP-003 Employee CANNOT update info WITHOUT MFA \u2705 None 0.04ms AI-001 AI Assistant can read directory \u2705 ai-assistant-directory 0.02ms AI-002 AI Assistant denied if TTL too long \u2705 None 0.04ms REG-001 Admin matches wildcard workday.* \u2705 admin-full-access 0.03ms REG-002 Admin matches wildcard hr.* \u2705 admin-full-access 0.02ms REG-003 Staff matches group-based policy \u2705 hr-staff-time-management 0.02ms","title":"Policy Verification"},{"location":"policy-verification/latest/#policy-verification-report","text":"Timestamp : 2026-02-02 21:32:34 Policy Version : unknown Status : \ud83d\udfe2 PASS","title":"Policy Verification Report"},{"location":"policy-verification/latest/#summary","text":"Metric Value Total Tests 10 Passed 10 Failed 0 Pass Rate 100.0%","title":"Summary"},{"location":"policy-verification/latest/#full-results","text":"ID Scenario Outcome Policy Duration ADM-001 Admin full access with MFA \u2705 admin-full-access 0.05ms ADM-002 Admin denied WITHOUT MFA \u2705 None 0.05ms EMP-001 Employee can read directory \u2705 employee-self-service-read 0.03ms EMP-002 Employee can manage own time off \u2705 employee-time-self-service 0.02ms EMP-003 Employee CANNOT update info WITHOUT MFA \u2705 None 0.04ms AI-001 AI Assistant can read directory \u2705 ai-assistant-directory 0.02ms AI-002 AI Assistant denied if TTL too long \u2705 None 0.04ms REG-001 Admin matches wildcard workday.* \u2705 admin-full-access 0.03ms REG-002 Admin matches wildcard hr.* \u2705 admin-full-access 0.02ms REG-003 Staff matches group-based policy \u2705 hr-staff-time-management 0.02ms","title":"Full Results"}]}